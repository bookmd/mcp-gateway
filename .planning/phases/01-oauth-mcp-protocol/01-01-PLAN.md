---
phase: 01-oauth-mcp-protocol
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - .env.example
  - src/config/oauth.ts
  - src/config/session.ts
  - src/auth/oauth-client.ts
  - src/auth/middleware.ts
  - src/routes/oauth.ts
  - src/server.ts
autonomous: true
user_setup:
  - service: google-oauth
    why: "Google OAuth authentication for Workspace users"
    env_vars:
      - name: GOOGLE_CLIENT_ID
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client ID"
      - name: GOOGLE_CLIENT_SECRET
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client ID"
    dashboard_config:
      - task: "Create OAuth 2.0 Client ID (Web application type)"
        location: "Google Cloud Console -> APIs & Services -> Credentials -> Create Credentials"
      - task: "Add authorized redirect URI: http://localhost:3000/auth/callback (dev) and https://gateway.company.com/auth/callback (prod)"
        location: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client ID -> Authorized redirect URIs"

must_haves:
  truths:
    - "User can visit /auth/login and be redirected to Google OAuth"
    - "OAuth callback validates hd claim and rejects non-company.com users"
    - "Session stores access_token, id_token, expires_at, authenticated_at"
    - "Auth middleware rejects requests after 7 days from authenticated_at"
  artifacts:
    - path: "package.json"
      provides: "Project dependencies"
      contains: "@modelcontextprotocol/sdk"
    - path: "src/auth/oauth-client.ts"
      provides: "PKCE flow with openid-client"
      exports: ["createAuthUrl", "handleCallback"]
    - path: "src/auth/middleware.ts"
      provides: "Session validation with weekly expiration"
      exports: ["requireAuth"]
    - path: "src/routes/oauth.ts"
      provides: "OAuth endpoints"
      contains: "/auth/login"
  key_links:
    - from: "src/routes/oauth.ts"
      to: "src/auth/oauth-client.ts"
      via: "import { createAuthUrl, handleCallback }"
      pattern: "handleCallback.*hd.*company\\.com"
    - from: "src/auth/middleware.ts"
      to: "session"
      via: "authenticated_at check"
      pattern: "Date\\.now\\(\\).*authenticated_at.*7.*24.*60.*60.*1000"
---

<objective>
Set up the project foundation and implement Google OAuth 2.1 with PKCE flow, including domain restriction validation and weekly re-authentication enforcement.

Purpose: Establishes the secure authentication foundation that all subsequent phases build upon. OAuth patterns must be correct from the start to avoid security retrofits.

Output: Working OAuth flow that authenticates @company.com users via Google, stores tokens in server-side sessions, and enforces 7-day re-authentication requirement.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-oauth-mcp-protocol/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Project Foundation Setup</name>
  <files>
    package.json
    tsconfig.json
    .env.example
    src/server.ts
    src/config/oauth.ts
    src/config/session.ts
  </files>
  <action>
Create Node.js 22 LTS project with TypeScript:

1. Initialize package.json with:
   - name: "mcp-gateway"
   - type: "module" (ESM)
   - engines: { "node": ">=22.0.0" }
   - scripts: { "dev": "tsx watch src/server.ts", "build": "tsc", "start": "node dist/server.js" }

2. Install dependencies:
   ```bash
   npm install @modelcontextprotocol/sdk zod openid-client fastify @fastify/sse @fastify/cookie @fastify/session
   npm install -D typescript tsx @types/node
   ```

3. Create tsconfig.json:
   - target: "ES2022"
   - module: "NodeNext"
   - moduleResolution: "NodeNext"
   - strict: true
   - outDir: "dist"
   - rootDir: "src"

4. Create .env.example with:
   ```
   # Google OAuth
   GOOGLE_CLIENT_ID=your-client-id
   GOOGLE_CLIENT_SECRET=your-client-secret
   GOOGLE_REDIRECT_URI=http://localhost:3000/auth/callback
   ALLOWED_DOMAIN=company.com

   # Session
   SESSION_SECRET=generate-a-secure-random-string-at-least-32-chars

   # Server
   PORT=3000
   NODE_ENV=development
   ```

5. Create src/config/oauth.ts:
   - Export GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, GOOGLE_REDIRECT_URI, ALLOWED_DOMAIN from env
   - Throw on missing required vars

6. Create src/config/session.ts:
   - Export SESSION_SECRET, session cookie options
   - maxAge: 7 * 24 * 60 * 60 * 1000 (7 days)
   - secure: process.env.NODE_ENV === 'production'
   - httpOnly: true
   - sameSite: 'lax' (allows OAuth redirects)

7. Create src/server.ts (basic Fastify app):
   - Import Fastify, register cookie and session plugins
   - Add health check endpoint GET /health
   - Listen on PORT
  </action>
  <verify>
npm install completes without errors
npm run dev starts server
curl http://localhost:3000/health returns 200
  </verify>
  <done>
Project runs with Fastify server, session middleware configured, environment variables validated on startup.
  </done>
</task>

<task type="auto">
  <name>Task 2: OAuth PKCE Flow Implementation</name>
  <files>
    src/auth/oauth-client.ts
    src/routes/oauth.ts
    src/server.ts
  </files>
  <action>
Implement Google OAuth 2.1 with PKCE using openid-client:

1. Create src/auth/oauth-client.ts:
   ```typescript
   import { Issuer, generators, Client } from 'openid-client';
   import { oauthConfig } from '../config/oauth.js';

   let client: Client;

   export async function initOAuthClient(): Promise<void> {
     const googleIssuer = await Issuer.discover('https://accounts.google.com');
     client = new googleIssuer.Client({
       client_id: oauthConfig.clientId,
       client_secret: oauthConfig.clientSecret,
       redirect_uris: [oauthConfig.redirectUri],
       response_types: ['code']
     });
   }

   export interface AuthUrlParams {
     codeVerifier: string;
     codeChallenge: string;
     state: string;
     nonce: string;
     authUrl: string;
   }

   export function createAuthUrl(): AuthUrlParams {
     const codeVerifier = generators.codeVerifier();
     const codeChallenge = generators.codeChallenge(codeVerifier);
     const state = generators.state();
     const nonce = generators.nonce();

     const authUrl = client.authorizationUrl({
       scope: 'openid email profile',
       code_challenge: codeChallenge,
       code_challenge_method: 'S256',
       state,
       nonce,
       hd: oauthConfig.allowedDomain // Domain hint (UI only, not security)
     });

     return { codeVerifier, codeChallenge, state, nonce, authUrl };
   }

   export interface CallbackResult {
     accessToken: string;
     idToken: string;
     expiresAt: number;
     email: string;
     hd: string;
   }

   export async function handleCallback(
     params: URLSearchParams,
     stored: { codeVerifier: string; state: string; nonce: string }
   ): Promise<CallbackResult> {
     const tokenSet = await client.callback(
       oauthConfig.redirectUri,
       Object.fromEntries(params),
       {
         code_verifier: stored.codeVerifier,
         state: stored.state,
         nonce: stored.nonce
       }
     );

     const claims = tokenSet.claims();

     // CRITICAL: Validate hd claim for domain restriction (AUTH-02)
     if (claims.hd !== oauthConfig.allowedDomain) {
       throw new Error(`Unauthorized domain: ${claims.hd}. Only ${oauthConfig.allowedDomain} accounts allowed.`);
     }

     return {
       accessToken: tokenSet.access_token!,
       idToken: tokenSet.id_token!,
       expiresAt: tokenSet.expires_at! * 1000, // Convert to ms
       email: claims.email as string,
       hd: claims.hd as string
     };
   }
   ```

2. Create src/routes/oauth.ts:
   ```typescript
   import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
   import { createAuthUrl, handleCallback, initOAuthClient } from '../auth/oauth-client.js';

   export async function oauthRoutes(app: FastifyInstance): Promise<void> {
     // Initialize OAuth client on plugin registration
     await initOAuthClient();

     // GET /auth/login - Initiate OAuth flow
     app.get('/auth/login', async (request: FastifyRequest, reply: FastifyReply) => {
       const { codeVerifier, state, nonce, authUrl } = createAuthUrl();

       // Store PKCE params in session
       request.session.set('oauth_code_verifier', codeVerifier);
       request.session.set('oauth_state', state);
       request.session.set('oauth_nonce', nonce);

       return reply.redirect(authUrl);
     });

     // GET /auth/callback - Handle OAuth callback
     app.get('/auth/callback', async (request: FastifyRequest, reply: FastifyReply) => {
       try {
         const params = new URLSearchParams(request.url.split('?')[1]);

         // Retrieve stored PKCE params
         const stored = {
           codeVerifier: request.session.get('oauth_code_verifier') as string,
           state: request.session.get('oauth_state') as string,
           nonce: request.session.get('oauth_nonce') as string
         };

         if (!stored.codeVerifier || !stored.state) {
           return reply.code(400).send({ error: 'Invalid session state' });
         }

         const result = await handleCallback(params, stored);

         // Regenerate session to prevent fixation
         await request.session.regenerate();

         // Store auth data
         request.session.set('access_token', result.accessToken);
         request.session.set('id_token', result.idToken);
         request.session.set('expires_at', result.expiresAt);
         request.session.set('authenticated_at', Date.now());
         request.session.set('email', result.email);
         request.session.set('hd', result.hd);

         // Clear PKCE params
         request.session.delete('oauth_code_verifier');
         request.session.delete('oauth_state');
         request.session.delete('oauth_nonce');

         return reply.send({
           success: true,
           email: result.email,
           message: 'Authentication successful. You can now connect from Cursor.'
         });
       } catch (error) {
         const message = error instanceof Error ? error.message : 'Authentication failed';
         return reply.code(401).send({ error: message });
       }
     });

     // GET /auth/status - Check auth status
     app.get('/auth/status', async (request: FastifyRequest, reply: FastifyReply) => {
       const email = request.session.get('email');
       const authenticatedAt = request.session.get('authenticated_at') as number | undefined;
       const expiresAt = request.session.get('expires_at') as number | undefined;

       if (!email || !authenticatedAt) {
         return reply.send({ authenticated: false });
       }

       const weekInMs = 7 * 24 * 60 * 60 * 1000;
       const weeklyExpired = Date.now() - authenticatedAt >= weekInMs;
       const tokenExpired = expiresAt ? Date.now() >= expiresAt : true;

       return reply.send({
         authenticated: !weeklyExpired && !tokenExpired,
         email,
         authenticatedAt: new Date(authenticatedAt).toISOString(),
         weeklyExpiresAt: new Date(authenticatedAt + weekInMs).toISOString(),
         tokenExpiresAt: expiresAt ? new Date(expiresAt).toISOString() : null
       });
     });

     // POST /auth/logout - Clear session
     app.post('/auth/logout', async (request: FastifyRequest, reply: FastifyReply) => {
       await request.session.destroy();
       return reply.send({ success: true });
     });
   }
   ```

3. Update src/server.ts to register oauth routes:
   ```typescript
   import { oauthRoutes } from './routes/oauth.js';

   // After session plugin registration
   await app.register(oauthRoutes);
   ```
  </action>
  <verify>
npm run dev starts without errors
curl http://localhost:3000/auth/login returns 302 redirect to accounts.google.com
curl http://localhost:3000/auth/status returns { "authenticated": false }
  </verify>
  <done>
OAuth PKCE flow implemented: /auth/login initiates flow with PKCE, /auth/callback validates domain and stores tokens, /auth/status shows auth state.
  </done>
</task>

<task type="auto">
  <name>Task 3: Auth Middleware with Weekly Expiration</name>
  <files>
    src/auth/middleware.ts
    src/server.ts
  </files>
  <action>
Create authentication middleware enforcing AUTH-04 (weekly re-authentication):

1. Create src/auth/middleware.ts:
   ```typescript
   import { FastifyRequest, FastifyReply, HookHandlerDoneFunction } from 'fastify';

   const WEEK_IN_MS = 7 * 24 * 60 * 60 * 1000;

   export interface UserContext {
     accessToken: string;
     email: string;
     sessionId: string;
   }

   declare module 'fastify' {
     interface FastifyRequest {
       userContext?: UserContext;
     }
   }

   export async function requireAuth(
     request: FastifyRequest,
     reply: FastifyReply
   ): Promise<void> {
     const accessToken = request.session.get('access_token') as string | undefined;
     const expiresAt = request.session.get('expires_at') as number | undefined;
     const authenticatedAt = request.session.get('authenticated_at') as number | undefined;
     const email = request.session.get('email') as string | undefined;

     // Check if session has auth data
     if (!accessToken || !authenticatedAt || !email) {
       reply.code(401).send({
         error: 'authentication_required',
         message: 'Please authenticate at /auth/login'
       });
       return;
     }

     // Check Google access token expiration
     if (expiresAt && Date.now() >= expiresAt) {
       reply.code(401).send({
         error: 'token_expired',
         message: 'Access token expired. Please re-authenticate at /auth/login'
       });
       return;
     }

     // AUTH-04: Check weekly re-authentication requirement
     if (Date.now() - authenticatedAt >= WEEK_IN_MS) {
       reply.code(401).send({
         error: 'reauthentication_required',
         message: 'Weekly re-authentication required. Please log in again at /auth/login'
       });
       return;
     }

     // Attach user context for downstream handlers
     request.userContext = {
       accessToken,
       email,
       sessionId: request.session.sessionId
     };
   }
   ```

2. Add a protected test endpoint in src/server.ts to verify middleware:
   ```typescript
   import { requireAuth } from './auth/middleware.js';

   // Test protected endpoint
   app.get('/protected', { preHandler: requireAuth }, async (request, reply) => {
     return {
       message: 'You are authenticated',
       email: request.userContext?.email,
       sessionId: request.userContext?.sessionId
     };
   });
   ```
  </action>
  <verify>
curl http://localhost:3000/protected returns 401 with "authentication_required"
After OAuth login (manual test with real credentials), /protected returns 200 with email
  </verify>
  <done>
Auth middleware validates session, token expiration, and weekly re-auth requirement. Protected endpoints receive userContext with accessToken and email.
  </done>
</task>

</tasks>

<verification>
1. Server starts: `npm run dev` runs without errors
2. Health check: `curl http://localhost:3000/health` returns 200
3. OAuth flow initiates: `curl -v http://localhost:3000/auth/login` returns 302 to Google
4. Auth status works: `curl http://localhost:3000/auth/status` returns JSON
5. Protected endpoint rejects unauthenticated: `curl http://localhost:3000/protected` returns 401
6. TypeScript compiles: `npm run build` succeeds
</verification>

<success_criteria>
- Project structure matches research recommendations (src/auth/, src/config/, src/routes/)
- OAuth PKCE flow uses openid-client with S256 code challenge method
- Domain restriction validates hd claim (not email domain)
- Session stores access_token, id_token, expires_at, authenticated_at
- Middleware enforces 7-day re-authentication window
- All endpoints return appropriate HTTP status codes
</success_criteria>

<output>
After completion, create `.planning/phases/01-oauth-mcp-protocol/01-01-SUMMARY.md`
</output>
