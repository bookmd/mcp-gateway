---
phase: 01-oauth-mcp-protocol
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mcp/server.ts
  - src/mcp/transports/sse.ts
  - src/routes/sse.ts
  - src/server.ts
autonomous: true

must_haves:
  truths:
    - "MCP server initializes with name and version"
    - "SSE endpoint accepts connections at /mcp/sse"
    - "MCP initialize handshake returns server capabilities"
    - "SSE connection stays open for bidirectional communication"
  artifacts:
    - path: "src/mcp/server.ts"
      provides: "MCP server instance configuration"
      exports: ["mcpServer", "initMcpServer"]
    - path: "src/mcp/transports/sse.ts"
      provides: "SSE transport adapter"
      exports: ["createSSETransport"]
    - path: "src/routes/sse.ts"
      provides: "SSE endpoint for Cursor connections"
      contains: "/mcp/sse"
  key_links:
    - from: "src/routes/sse.ts"
      to: "src/mcp/server.ts"
      via: "mcpServer.connect(transport)"
      pattern: "mcpServer\\.connect"
    - from: "src/routes/sse.ts"
      to: "@fastify/sse"
      via: "reply.sse"
      pattern: "reply\\.sse"
---

<objective>
Implement the MCP server with SSE transport, enabling Cursor to establish connections and perform protocol handshake.

Purpose: Creates the MCP communication layer that Cursor uses to interact with the gateway. This runs in parallel with OAuth setup (Plan 01) as they are independent concerns.

Output: Working MCP server accepting SSE connections at /mcp/sse, responding to protocol initialize requests with server capabilities.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-oauth-mcp-protocol/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: MCP Server Initialization</name>
  <files>
    src/mcp/server.ts
    src/types/mcp.ts
  </files>
  <action>
Create MCP server instance using @modelcontextprotocol/sdk:

1. Create src/types/mcp.ts for type declarations:
   ```typescript
   export interface UserContext {
     accessToken: string;
     email: string;
     sessionId: string;
   }

   // Extended session type for MCP connections
   export interface McpSession {
     userContext: UserContext;
     connectedAt: number;
   }
   ```

2. Create src/mcp/server.ts:
   ```typescript
   import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';

   // MCP Server instance
   let mcpServer: McpServer;

   export function getMcpServer(): McpServer {
     if (!mcpServer) {
       throw new Error('MCP server not initialized. Call initMcpServer() first.');
     }
     return mcpServer;
   }

   export function initMcpServer(): McpServer {
     mcpServer = new McpServer({
       name: 'mcp-gateway',
       version: '1.0.0'
     });

     // Log server initialization
     console.log('[MCP] Server initialized: mcp-gateway v1.0.0');

     return mcpServer;
   }
   ```

Note on MCP SDK: The @modelcontextprotocol/sdk exports McpServer from the server/mcp.js path. Check actual exports with `npm ls @modelcontextprotocol/sdk` and inspect node_modules if needed. The SDK may use `Server` instead of `McpServer` - adapt import accordingly.
  </action>
  <verify>
Import compiles: Add `import { initMcpServer } from './mcp/server.js'` to server.ts
`npm run build` completes without TypeScript errors
  </verify>
  <done>
MCP server module created with initialization function returning configured McpServer instance.
  </done>
</task>

<task type="auto">
  <name>Task 2: SSE Transport and Endpoint</name>
  <files>
    src/mcp/transports/sse.ts
    src/routes/sse.ts
    src/server.ts
  </files>
  <action>
Implement SSE transport and endpoint for MCP connections:

1. Create src/mcp/transports/sse.ts:
   ```typescript
   import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
   import type { FastifyReply } from 'fastify';

   /**
    * Creates an SSE transport for MCP communication.
    *
    * Note: The MCP SDK's SSEServerTransport expects specific SSE
    * message handling. We adapt Fastify's SSE to work with it.
    */
   export function createSSETransport(
     endpoint: string,
     reply: FastifyReply
   ): SSEServerTransport {
     // The SDK expects a response object with SSE capabilities
     // Fastify's @fastify/sse provides reply.sse()
     return new SSEServerTransport(endpoint, reply.raw);
   }
   ```

Note: The MCP SDK's SSEServerTransport interface may vary. Check the actual SDK exports:
- It may accept (endpoint, response) or different parameters
- Adapt based on actual SDK API found in node_modules/@modelcontextprotocol/sdk/dist/server/sse.d.ts

2. Create src/routes/sse.ts:
   ```typescript
   import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
   import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
   import { getMcpServer } from '../mcp/server.js';

   // Track active connections for debugging
   const activeConnections = new Map<string, { email?: string; connectedAt: number }>();

   export async function sseRoutes(app: FastifyInstance): Promise<void> {
     // GET /mcp/sse - SSE endpoint for MCP connections
     // Note: Authentication will be added in Plan 03
     app.get('/mcp/sse', async (request: FastifyRequest, reply: FastifyReply) => {
       const connectionId = `conn-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

       console.log(`[MCP] New SSE connection: ${connectionId}`);

       // Set SSE headers
       reply.raw.writeHead(200, {
         'Content-Type': 'text/event-stream',
         'Cache-Control': 'no-cache',
         'Connection': 'keep-alive',
         'X-Accel-Buffering': 'no' // Disable nginx buffering if present
       });

       // Create SSE transport
       const transport = new SSEServerTransport('/mcp/sse', reply.raw);

       // Track connection
       activeConnections.set(connectionId, {
         connectedAt: Date.now()
       });

       // Connect MCP server to this transport
       const mcpServer = getMcpServer();

       try {
         await mcpServer.connect(transport);
         console.log(`[MCP] Client connected: ${connectionId}`);
       } catch (error) {
         console.error(`[MCP] Connection error: ${connectionId}`, error);
         activeConnections.delete(connectionId);
         reply.raw.end();
         return;
       }

       // Handle disconnect
       request.raw.on('close', () => {
         console.log(`[MCP] Client disconnected: ${connectionId}`);
         activeConnections.delete(connectionId);
         transport.close?.();
       });

       // Keep connection alive - don't return/end reply
     });

     // GET /mcp/status - Connection status (for debugging)
     app.get('/mcp/status', async (request: FastifyRequest, reply: FastifyReply) => {
       return {
         activeConnections: activeConnections.size,
         connections: Array.from(activeConnections.entries()).map(([id, info]) => ({
           id,
           ...info,
           duration: Date.now() - info.connectedAt
         }))
       };
     });

     // POST /mcp/message - Message endpoint for SSE transport
     // Some SSE implementations require a separate POST endpoint for client->server messages
     app.post('/mcp/message', async (request: FastifyRequest, reply: FastifyReply) => {
       // This endpoint receives JSON-RPC messages from the client
       // The transport handles routing to the correct connection
       // For now, return 501 - will implement if needed based on SDK requirements
       return reply.code(501).send({
         error: 'not_implemented',
         message: 'POST message endpoint - implement based on SDK transport requirements'
       });
     });
   }
   ```

3. Update src/server.ts to register SSE routes and initialize MCP:
   ```typescript
   import fastifySse from '@fastify/sse';
   import { initMcpServer } from './mcp/server.js';
   import { sseRoutes } from './routes/sse.js';

   // Register SSE plugin
   await app.register(fastifySse);

   // Initialize MCP server before routes
   initMcpServer();

   // Register SSE routes (after MCP init)
   await app.register(sseRoutes);
   ```

Note on SDK adaptation:
- The exact API depends on @modelcontextprotocol/sdk version
- Check node_modules/@modelcontextprotocol/sdk/dist/server/sse.js for actual exports
- The transport may need different initialization - adapt based on actual API
- Some versions use `connect()`, others may use different method names
  </action>
  <verify>
npm run dev starts without errors
curl -N http://localhost:3000/mcp/sse shows SSE connection (stays open)
curl http://localhost:3000/mcp/status returns { "activeConnections": 0 }
Open /mcp/sse in browser shows event stream starting
  </verify>
  <done>
SSE endpoint accepts connections at /mcp/sse, MCP server connects transport, connection tracking works for debugging.
  </done>
</task>

</tasks>

<verification>
1. MCP module loads: `npm run build` compiles without errors
2. SSE headers correct: `curl -v -N http://localhost:3000/mcp/sse` shows Content-Type: text/event-stream
3. Connection stays open: SSE connection doesn't immediately close
4. Status endpoint works: `curl http://localhost:3000/mcp/status` returns JSON
5. Multiple connections: Open two browser tabs to /mcp/sse, status shows 2 connections
</verification>

<success_criteria>
- MCP server initializes with name "mcp-gateway" and version "1.0.0"
- SSE endpoint at /mcp/sse accepts connections with correct headers
- MCP transport connects to server instance
- Connection tracking shows active connections
- Server logs connection events for debugging
</success_criteria>

<output>
After completion, create `.planning/phases/01-oauth-mcp-protocol/01-02-SUMMARY.md`
</output>
