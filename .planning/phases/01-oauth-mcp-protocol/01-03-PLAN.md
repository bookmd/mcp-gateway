---
phase: 01-oauth-mcp-protocol
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - src/routes/sse.ts
  - src/mcp/handlers.ts
  - src/auth/middleware.ts
autonomous: false

must_haves:
  truths:
    - "SSE endpoint requires authentication (401 without valid session)"
    - "MCP handlers receive userContext with accessToken"
    - "Each user's MCP session is isolated with their own OAuth credentials"
    - "Full OAuth-to-MCP flow works end-to-end"
  artifacts:
    - path: "src/mcp/handlers.ts"
      provides: "MCP request handlers with user context"
      exports: ["registerMcpHandlers"]
    - path: "src/routes/sse.ts"
      provides: "Authenticated SSE endpoint"
      contains: "requireAuth"
  key_links:
    - from: "src/routes/sse.ts"
      to: "src/auth/middleware.ts"
      via: "preHandler: requireAuth"
      pattern: "preHandler.*requireAuth"
    - from: "src/routes/sse.ts"
      to: "request.userContext"
      via: "user context propagation"
      pattern: "userContext.*accessToken"
    - from: "src/mcp/handlers.ts"
      to: "context.userContext"
      via: "MCP handler context"
      pattern: "context\\.userContext\\.accessToken"
---

<objective>
Wire OAuth authentication to MCP transport, ensuring each user's API calls use their individual credentials (INFRA-03) and validate the complete flow end-to-end.

Purpose: Completes the Phase 1 integration by connecting OAuth sessions to MCP connections. This is the critical security boundary ensuring users can only access their own data.

Output: Authenticated MCP connections where each user's handlers have access to their OAuth credentials, verified with end-to-end testing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-oauth-mcp-protocol/01-RESEARCH.md
@.planning/phases/01-oauth-mcp-protocol/01-01-SUMMARY.md
@.planning/phases/01-oauth-mcp-protocol/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire Authentication to SSE Endpoint</name>
  <files>
    src/routes/sse.ts
    src/mcp/handlers.ts
  </files>
  <action>
Add authentication to SSE endpoint and propagate user context to MCP handlers:

1. Update src/routes/sse.ts to require authentication:
   ```typescript
   import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
   import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
   import { getMcpServer } from '../mcp/server.js';
   import { requireAuth, UserContext } from '../auth/middleware.js';

   // Track active connections with user info
   const activeConnections = new Map<string, {
     email: string;
     connectedAt: number;
     sessionId: string;
   }>();

   export async function sseRoutes(app: FastifyInstance): Promise<void> {
     // GET /mcp/sse - Authenticated SSE endpoint for MCP connections
     app.get('/mcp/sse', {
       preHandler: requireAuth  // <-- Auth required
     }, async (request: FastifyRequest, reply: FastifyReply) => {
       const userContext = request.userContext!;
       const connectionId = `conn-${userContext.sessionId}-${Date.now()}`;

       console.log(`[MCP] Authenticated SSE connection: ${connectionId} (${userContext.email})`);

       // Set SSE headers
       reply.raw.writeHead(200, {
         'Content-Type': 'text/event-stream',
         'Cache-Control': 'no-cache',
         'Connection': 'keep-alive',
         'X-Accel-Buffering': 'no'
       });

       // Create SSE transport
       const transport = new SSEServerTransport('/mcp/sse', reply.raw);

       // Track connection with user info
       activeConnections.set(connectionId, {
         email: userContext.email,
         connectedAt: Date.now(),
         sessionId: userContext.sessionId
       });

       // Connect MCP server with user context
       const mcpServer = getMcpServer();

       try {
         // Pass user context to transport/server
         // The exact API depends on SDK version - may need to store in transport metadata
         (transport as any).userContext = userContext;

         await mcpServer.connect(transport);
         console.log(`[MCP] Client connected: ${connectionId} (${userContext.email})`);
       } catch (error) {
         console.error(`[MCP] Connection error: ${connectionId}`, error);
         activeConnections.delete(connectionId);
         reply.raw.end();
         return;
       }

       // Handle disconnect
       request.raw.on('close', () => {
         console.log(`[MCP] Client disconnected: ${connectionId} (${userContext.email})`);
         activeConnections.delete(connectionId);
         transport.close?.();
       });
     });

     // GET /mcp/status - Updated to show user info (protected)
     app.get('/mcp/status', {
       preHandler: requireAuth
     }, async (request: FastifyRequest, reply: FastifyReply) => {
       return {
         currentUser: request.userContext?.email,
         activeConnections: activeConnections.size,
         connections: Array.from(activeConnections.entries()).map(([id, info]) => ({
           id,
           email: info.email,
           duration: Date.now() - info.connectedAt
         }))
       };
     });
   }
   ```

2. Create src/mcp/handlers.ts with a test tool that uses user context:
   ```typescript
   import { getMcpServer } from './server.js';
   import type { UserContext } from '../auth/middleware.js';

   /**
    * Register MCP handlers that use per-user OAuth credentials.
    * Future phases will add actual Google API tools here.
    */
   export function registerMcpHandlers(): void {
     const server = getMcpServer();

     // List available tools
     server.setRequestHandler('tools/list', async () => {
       return {
         tools: [
           {
             name: 'whoami',
             description: 'Returns the authenticated user information',
             inputSchema: {
               type: 'object',
               properties: {},
               required: []
             }
           },
           {
             name: 'test_auth',
             description: 'Tests that OAuth credentials are available for API calls',
             inputSchema: {
               type: 'object',
               properties: {},
               required: []
             }
           }
         ]
       };
     });

     // Handle tool calls
     server.setRequestHandler('tools/call', async (request, context) => {
       // Get user context from transport
       // Note: The exact way to access user context depends on SDK version
       // This may need adaptation based on how context is passed
       const transport = context.transport as any;
       const userContext: UserContext | undefined = transport?.userContext;

       if (!userContext) {
         return {
           content: [{
             type: 'text',
             text: 'Error: No user context available. Authentication may have failed.'
           }],
           isError: true
         };
       }

       const toolName = request.params.name;

       switch (toolName) {
         case 'whoami':
           return {
             content: [{
               type: 'text',
               text: JSON.stringify({
                 email: userContext.email,
                 sessionId: userContext.sessionId,
                 hasAccessToken: !!userContext.accessToken
               }, null, 2)
             }]
           };

         case 'test_auth':
           // Verify we have credentials that could be used for API calls
           // In future phases, this would actually call a Google API
           const hasToken = !!userContext.accessToken;
           const tokenPreview = userContext.accessToken
             ? `${userContext.accessToken.substring(0, 10)}...`
             : 'none';

           return {
             content: [{
               type: 'text',
               text: JSON.stringify({
                 authenticated: hasToken,
                 email: userContext.email,
                 tokenPreview,
                 message: hasToken
                   ? 'OAuth credentials available for API calls'
                   : 'No OAuth credentials - user needs to authenticate'
               }, null, 2)
             }]
           };

         default:
           return {
             content: [{
               type: 'text',
               text: `Unknown tool: ${toolName}`
             }],
             isError: true
           };
       }
     });

     console.log('[MCP] Handlers registered: whoami, test_auth');
   }
   ```

3. Update src/server.ts to register handlers after MCP init:
   ```typescript
   import { registerMcpHandlers } from './mcp/handlers.js';

   // After initMcpServer()
   registerMcpHandlers();
   ```
  </action>
  <verify>
npm run dev starts without errors
curl http://localhost:3000/mcp/sse returns 401 (unauthenticated)
curl http://localhost:3000/mcp/status returns 401 (unauthenticated)
  </verify>
  <done>
SSE endpoint requires authentication, user context propagated to MCP handlers, test tools available to verify per-user credentials.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: End-to-End Flow Verification</name>
  <what-built>
Complete Phase 1 integration: OAuth PKCE flow with domain restriction, MCP server with SSE transport, per-user credential propagation. Requirements covered:
- AUTH-01: OAuth 2.1 with PKCE
- AUTH-02: @company.com domain restriction (hd claim)
- AUTH-04: Weekly re-authentication
- INFRA-01: SSE transport for MCP
- INFRA-03: Per-user OAuth credentials
  </what-built>
  <how-to-verify>
**Prerequisites:**
- Google OAuth credentials configured in .env (GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET)
- Redirect URI registered in Google Cloud Console

**Test Flow:**

1. **Start server:**
   ```bash
   npm run dev
   ```

2. **Test unauthenticated access (should fail):**
   ```bash
   curl http://localhost:3000/mcp/sse
   # Expected: 401 {"error":"authentication_required",...}

   curl http://localhost:3000/protected
   # Expected: 401 {"error":"authentication_required",...}
   ```

3. **Initiate OAuth login:**
   Open in browser: http://localhost:3000/auth/login
   - Should redirect to Google consent screen
   - Sign in with @company.com account
   - After consent, redirected back to callback
   - Expected: {"success":true,"email":"you@company.com",...}

4. **Test domain restriction (if possible):**
   - If you have access to a non-company.com Google account
   - Try logging in with that account
   - Expected: 401 "Unauthorized domain: [other-domain]"

5. **Check auth status:**
   ```bash
   # Use the session cookie from the browser (copy from DevTools > Application > Cookies)
   curl -b "sessionId=YOUR_SESSION_COOKIE" http://localhost:3000/auth/status
   # Expected: {"authenticated":true,"email":"you@company.com",...}
   ```

6. **Test protected SSE endpoint:**
   Open in browser (with session cookie): http://localhost:3000/mcp/sse
   - Should show SSE event stream starting
   - Check server logs for "[MCP] Authenticated SSE connection..."

7. **Test MCP status:**
   ```bash
   curl -b "sessionId=YOUR_SESSION_COOKIE" http://localhost:3000/mcp/status
   # Expected: {"currentUser":"you@company.com","activeConnections":N,...}
   ```

8. **Verify session expiration logic:**
   ```bash
   curl -b "sessionId=YOUR_SESSION_COOKIE" http://localhost:3000/auth/status
   # Check weeklyExpiresAt is 7 days from authenticatedAt
   ```

**Success indicators:**
- [ ] OAuth login redirects to Google and back
- [ ] Only @company.com accounts succeed (hd claim validated)
- [ ] Session stores tokens and timestamps
- [ ] Unauthenticated requests to /mcp/sse return 401
- [ ] Authenticated requests to /mcp/sse establish SSE connection
- [ ] Server logs show user email in connection events
  </how-to-verify>
  <resume-signal>
Type "approved" if all checks pass, or describe any issues encountered.

Common issues to report:
- OAuth redirect URI mismatch (check Google Console config)
- Session cookie not persisting (check cookie settings)
- MCP connection failing (check SDK version compatibility)
  </resume-signal>
</task>

</tasks>

<verification>
1. Unauthenticated SSE returns 401
2. OAuth flow completes with @company.com account
3. Non-company.com accounts are rejected with clear error
4. Authenticated SSE connection established
5. MCP status shows authenticated user's email
6. Server logs include user email in all MCP events
</verification>

<success_criteria>
Phase 1 requirements validated:
- AUTH-01: OAuth 2.1 with PKCE flow working end-to-end
- AUTH-02: hd claim validation rejects non-company.com users
- AUTH-04: Session tracks authenticated_at for weekly expiration
- INFRA-01: SSE transport accepts MCP connections from authenticated users
- INFRA-03: Each MCP handler has access to user's OAuth accessToken
</success_criteria>

<output>
After completion, create `.planning/phases/01-oauth-mcp-protocol/01-03-SUMMARY.md`
</output>
