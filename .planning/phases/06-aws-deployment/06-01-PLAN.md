---
phase: 06-aws-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
  - .dockerignore
  - src/server.ts
autonomous: true

must_haves:
  truths:
    - "Application builds into production Docker image"
    - "Container starts and responds to health checks"
    - "Container handles SIGTERM gracefully during shutdown"
    - "Image size is minimized using multi-stage build"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage production container build"
      contains: "FROM node:22-alpine"
    - path: ".dockerignore"
      provides: "Build context exclusions"
      contains: "node_modules"
    - path: "src/server.ts"
      provides: "Graceful shutdown handler"
      contains: "SIGTERM"
  key_links:
    - from: "Dockerfile"
      to: "dist/server.js"
      via: "CMD instruction"
      pattern: "CMD.*node.*dist/server"
    - from: "src/server.ts"
      to: "process.on('SIGTERM')"
      via: "Signal handler registration"
      pattern: "process\\.on\\(['\"]SIGTERM['\"]"
---

<objective>
Prepare the MCP Gateway application for containerized deployment by creating a production Dockerfile and implementing graceful shutdown handling.

Purpose: ECS Fargate requires a Docker container that builds efficiently, runs as non-root, responds to health checks, and handles SIGTERM signals for graceful shutdown during deployments and scaling events.

Output: Production-ready Dockerfile with multi-stage build, .dockerignore for efficient builds, and updated server.ts with SIGTERM handler.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-aws-deployment/06-RESEARCH.md

# Application entry point requiring graceful shutdown
@src/server.ts

# Build configuration
@tsconfig.json
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create production Dockerfile with multi-stage build</name>
  <files>Dockerfile, .dockerignore</files>
  <action>
Create a production Dockerfile following Node.js Docker best practices from RESEARCH.md:

1. **Dockerfile** with multi-stage build:
   - Build stage: `FROM node:22-alpine AS builder`
     - WORKDIR /app
     - Copy package*.json, run `npm ci` (all deps for TypeScript build)
     - Copy source files
     - Run `npm run build` to compile TypeScript
   - Production stage: `FROM node:22-alpine`
     - ENV NODE_ENV=production
     - Install curl for health checks: `RUN apk add --no-cache curl`
     - WORKDIR /app
     - Copy package*.json, run `npm ci --omit=dev`
     - Copy dist/ from builder stage
     - Switch to non-root user: `USER node`
     - EXPOSE 3000
     - Add HEALTHCHECK using curl to /health endpoint (interval=30s, timeout=5s, start-period=10s, retries=3)
     - CMD ["node", "dist/server.js"] (NOT npm start - npm swallows SIGTERM)

2. **.dockerignore** to exclude:
   - node_modules
   - dist (built in container)
   - .git, .gitignore
   - .env, .env.local, .env.example
   - .planning
   - *.md (except Dockerfile-related)
   - .vscode, .idea
   - coverage, .nyc_output
   - test-*.mjs (test scripts)

IMPORTANT: Use `node:22-alpine` (not `node:22`) for 40MB vs 350MB image size. Fargate pulls image on every task start - smaller is faster.
  </action>
  <verify>
Run `docker build -t mcp-gateway:test .` from project root - build should complete without errors.
Run `docker images mcp-gateway:test --format "{{.Size}}"` - image size should be under 200MB.
  </verify>
  <done>
Dockerfile creates working container image under 200MB with non-root user and health check configured.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add graceful shutdown handler to server</name>
  <files>src/server.ts</files>
  <action>
Add SIGTERM handler to src/server.ts for graceful shutdown during ECS deployments:

1. Import the activeConnections map from routes/sse.ts (or export it if not already exported)

2. Add shutdown handler AFTER server starts listening:
```typescript
// Graceful shutdown on SIGTERM (ECS sends this before SIGKILL)
process.on('SIGTERM', async () => {
  app.log.info('SIGTERM received, starting graceful shutdown');

  // Stop accepting new connections
  await app.close();
  app.log.info('Fastify server closed, no new connections accepted');

  // Close all active MCP connections (import from routes/sse.ts)
  app.log.info(`Closing ${activeConnections.size} active MCP connections`);
  for (const [sessionId, data] of activeConnections) {
    try {
      app.log.info(`Closing MCP connection: ${sessionId}`);
      await data.transport.close();
    } catch (error) {
      app.log.error({ error }, `Error closing MCP connection ${sessionId}`);
    }
  }

  app.log.info('Graceful shutdown complete, exiting');
  process.exit(0);
});
```

3. Add handlers for uncaught errors (production safety):
```typescript
process.on('uncaughtException', (error) => {
  app.log.fatal({ error }, 'Uncaught exception');
  process.exit(1);
});

process.on('unhandledRejection', (reason) => {
  app.log.fatal({ reason }, 'Unhandled promise rejection');
  process.exit(1);
});
```

4. If activeConnections is not exported from routes/sse.ts, update that file to export it.

IMPORTANT: ECS default stopTimeout is 30 seconds. The handler must complete within this window or the container will be forcefully killed with SIGKILL.
  </action>
  <verify>
Run `npm run build` - TypeScript should compile without errors.
Run `docker build -t mcp-gateway:test .` - container builds successfully with updated code.
Test SIGTERM locally: Start server with `npm run dev`, then in another terminal run `kill -SIGTERM $(pgrep -f "tsx watch")` - should see "SIGTERM received" log message before exit.
  </verify>
  <done>
Server handles SIGTERM by closing HTTP server and all active MCP connections before exiting cleanly. Uncaught errors log and exit with code 1.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify Docker container runs correctly</name>
  <files></files>
  <action>
Build and run the Docker container locally to verify it works:

1. Build the image:
   ```bash
   docker build -t mcp-gateway:local .
   ```

2. Run the container (without real AWS/Google credentials, just checking startup):
   ```bash
   docker run -d --name mcp-test \
     -p 3000:3000 \
     -e NODE_ENV=production \
     -e PORT=3000 \
     -e SESSION_SECRET=test-secret-for-docker-verification \
     -e GOOGLE_CLIENT_ID=test \
     -e GOOGLE_CLIENT_SECRET=test \
     -e GOOGLE_REDIRECT_URI=http://localhost:3000/oauth/callback \
     -e ALLOWED_DOMAIN=test.com \
     -e AWS_REGION=us-east-1 \
     -e AWS_ACCESS_KEY_ID=test \
     -e AWS_SECRET_ACCESS_KEY=test \
     -e DYNAMODB_TABLE_NAME=mcp-gateway-sessions \
     -e KMS_KEY_ID=test \
     mcp-gateway:local
   ```

3. Check health endpoint:
   ```bash
   curl http://localhost:3000/health
   ```
   Should return `{"status":"ok","timestamp":"..."}`.

4. Check container health status:
   ```bash
   docker inspect mcp-test --format='{{.State.Health.Status}}'
   ```
   Should eventually show "healthy" (may take 30-40 seconds for first check).

5. Check logs for any startup errors:
   ```bash
   docker logs mcp-test
   ```
   Should show server listening message, may show AWS credential warnings (expected with fake creds).

6. Clean up:
   ```bash
   docker stop mcp-test && docker rm mcp-test
   ```

NOTE: Container will fail to connect to DynamoDB/KMS with fake credentials, but HTTP server and health check should work. Production deployment will use real credentials.
  </action>
  <verify>
`curl http://localhost:3000/health` returns 200 with JSON response while container is running.
Docker health check reports "healthy" status after initial check interval.
Container logs show "Server listening on http://0.0.0.0:3000".
  </verify>
  <done>
Docker container builds, starts, responds to health checks, and can be stopped cleanly. Ready for ECS deployment.
  </done>
</task>

</tasks>

<verification>
1. `docker build -t mcp-gateway:test .` completes successfully
2. Docker image size under 200MB
3. Container responds to /health endpoint with 200 status
4. Container health check reports "healthy"
5. SIGTERM handler logged during container stop
6. TypeScript compiles without errors (`npm run build`)
</verification>

<success_criteria>
- Production Dockerfile exists with multi-stage build, non-root user, and HEALTHCHECK
- .dockerignore excludes node_modules, .git, .env, .planning
- server.ts handles SIGTERM for graceful shutdown
- Container builds in under 2 minutes
- Container image under 200MB
- Health endpoint accessible in running container
</success_criteria>

<output>
After completion, create `.planning/phases/06-aws-deployment/06-01-SUMMARY.md`
</output>
