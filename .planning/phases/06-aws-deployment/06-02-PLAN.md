---
phase: 06-aws-deployment
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - infra/bin/app.ts
  - infra/lib/fargate-stack.ts
  - infra/cdk.json
  - infra/package.json
  - infra/tsconfig.json
autonomous: true
user_setup:
  - service: aws
    why: "CDK deployment requires AWS credentials with ECS/ECR/VPC permissions"
    env_vars:
      - name: AWS_ACCESS_KEY_ID
        source: "AWS IAM console -> Security credentials -> Access keys"
      - name: AWS_SECRET_ACCESS_KEY
        source: "AWS IAM console -> Security credentials -> Access keys"
      - name: AWS_REGION
        source: "Default region for deployment (e.g., us-east-1)"
    dashboard_config:
      - task: "Ensure IAM user has AdministratorAccess or specific ECS/VPC/ECR permissions"
        location: "AWS IAM console -> Users -> Permissions"

must_haves:
  truths:
    - "Gateway runs as containerized service on ECS Fargate cluster"
    - "Application Load Balancer routes HTTP traffic to Fargate tasks"
    - "Gateway scales automatically based on connection load"
    - "Health check endpoint enables automatic task restart on failures"
  artifacts:
    - path: "infra/bin/app.ts"
      provides: "CDK app entry point"
      contains: "new McpGatewayStack"
    - path: "infra/lib/fargate-stack.ts"
      provides: "ECS Fargate stack definition"
      contains: "ApplicationLoadBalancedFargateService"
    - path: "infra/cdk.json"
      provides: "CDK configuration"
      contains: "app"
    - path: "infra/package.json"
      provides: "CDK dependencies"
      contains: "aws-cdk-lib"
  key_links:
    - from: "infra/lib/fargate-stack.ts"
      to: "Dockerfile"
      via: "ContainerImage.fromAsset"
      pattern: "ContainerImage\\.fromAsset"
    - from: "infra/lib/fargate-stack.ts"
      to: "DynamoDB table"
      via: "IAM permissions"
      pattern: "grantReadWriteData|fromTableName"
    - from: "infra/lib/fargate-stack.ts"
      to: "KMS key"
      via: "IAM permissions"
      pattern: "grantEncryptDecrypt|fromKeyArn"
---

<objective>
Create AWS CDK infrastructure for deploying the MCP Gateway on ECS Fargate with Application Load Balancer, auto-scaling, and proper IAM permissions.

Purpose: The gateway needs production infrastructure that handles HTTPS traffic, scales based on connection load, integrates with existing DynamoDB/KMS resources, and restarts unhealthy tasks automatically.

Output: Complete CDK stack that can be deployed with `cdk deploy`, creating VPC, ECS cluster, Fargate service, ALB, and all supporting infrastructure.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-aws-deployment/06-RESEARCH.md
@.planning/phases/06-aws-deployment/06-01-SUMMARY.md

# Dockerfile from Plan 06-01
@Dockerfile

# Current environment configuration
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CDK infrastructure project</name>
  <files>infra/bin/app.ts, infra/lib/fargate-stack.ts, infra/cdk.json, infra/package.json, infra/tsconfig.json</files>
  <action>
Create the CDK infrastructure project in the `infra/` directory:

1. **infra/package.json**:
```json
{
  "name": "mcp-gateway-infra",
  "version": "1.0.0",
  "scripts": {
    "build": "tsc",
    "cdk": "cdk",
    "synth": "cdk synth",
    "deploy": "cdk deploy",
    "destroy": "cdk destroy"
  },
  "devDependencies": {
    "@types/node": "^22.0.0",
    "aws-cdk": "^2.180.0",
    "typescript": "^5.9.0"
  },
  "dependencies": {
    "aws-cdk-lib": "^2.180.0",
    "constructs": "^10.4.0"
  }
}
```

2. **infra/tsconfig.json**:
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "lib": ["ES2022"],
    "strict": true,
    "noEmitOnError": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "dist",
    "declaration": true
  },
  "include": ["bin/**/*", "lib/**/*"],
  "exclude": ["node_modules", "dist", "cdk.out"]
}
```

3. **infra/cdk.json**:
```json
{
  "app": "npx ts-node --esm bin/app.ts",
  "watch": {
    "include": ["**"],
    "exclude": ["node_modules", "cdk.out", "**/*.d.ts", "**/*.js"]
  },
  "context": {
    "@aws-cdk/aws-lambda:recognizeLayerVersion": true,
    "@aws-cdk/core:checkSecretUsage": true,
    "@aws-cdk/core:target-partitions": ["aws"]
  }
}
```

4. **infra/bin/app.ts** (CDK app entry point):
```typescript
#!/usr/bin/env node
import 'source-map-support/register';
import * as cdk from 'aws-cdk-lib';
import { McpGatewayStack } from '../lib/fargate-stack.js';

const app = new cdk.App();

new McpGatewayStack(app, 'McpGatewayStack', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION || 'us-east-1',
  },
  description: 'MCP Gateway for Google Workspace - ECS Fargate deployment',
});
```

5. **infra/lib/fargate-stack.ts** (main stack - see detailed implementation below):

The stack should include:
- VPC with 2 AZs and 1 NAT Gateway (cost optimization for 20 users)
- ECS Cluster with Container Insights enabled
- ApplicationLoadBalancedFargateService with:
  - 512 CPU (0.5 vCPU), 1024 MB memory
  - desiredCount: 1 (scales from 1-3)
  - Container built from ../Dockerfile
  - Environment variables for non-sensitive config
  - Secrets from environment (will use existing AWS credentials)
  - CloudWatch logging with 7-day retention
  - Health check on /health endpoint
  - HTTP listener on port 80 (HTTPS with custom domain deferred)
  - Circuit breaker with rollback
- Auto-scaling based on target connection count (50/100 thresholds)
- IAM permissions for existing DynamoDB table and KMS key
- Stack outputs for ALB DNS name and service ARN

IMPORTANT: For initial deployment, use HTTP only (port 80). HTTPS requires ACM certificate and custom domain which can be added later. The research notes this as acceptable for POC.

Environment variables to pass to container:
- NODE_ENV=production
- PORT=3000
- AWS_REGION (from stack)
- DYNAMODB_TABLE_NAME=mcp-gateway-sessions
- All OAuth-related vars should come from AWS Secrets Manager or be passed at deploy time

For this initial deployment, we'll use environment variables passed via CDK context or environment. Secrets Manager integration can be added in a follow-up if needed.
  </action>
  <verify>
Run from infra/ directory:
- `npm install` completes without errors
- `npm run build` compiles TypeScript without errors
- `npx cdk synth` generates CloudFormation template (may warn about missing AWS credentials)
  </verify>
  <done>
CDK infrastructure project exists with valid TypeScript, compiles successfully, and synthesizes CloudFormation template.
  </done>
</task>

<task type="auto">
  <name>Task 2: Deploy CDK stack to AWS</name>
  <files></files>
  <action>
Deploy the CDK stack to AWS:

1. First, ensure AWS credentials are configured:
   ```bash
   aws sts get-caller-identity
   ```
   If this fails, user needs to configure AWS credentials.

2. Bootstrap CDK (required once per account/region):
   ```bash
   cd infra
   npx cdk bootstrap
   ```
   This creates the CDKToolkit stack with S3 bucket for assets.

3. Synthesize and review the stack:
   ```bash
   npx cdk synth
   ```
   Review the generated CloudFormation in cdk.out/ to verify resources.

4. Deploy the stack:
   ```bash
   npx cdk deploy --require-approval never
   ```

   If deployment requires environment variables that aren't set, pass them:
   ```bash
   npx cdk deploy --require-approval never \
     --context googleClientId=$GOOGLE_CLIENT_ID \
     --context googleClientSecret=$GOOGLE_CLIENT_SECRET \
     --context googleRedirectUri=$GOOGLE_REDIRECT_URI \
     --context allowedDomain=$ALLOWED_DOMAIN \
     --context sessionSecret=$SESSION_SECRET \
     --context kmsKeyId=$KMS_KEY_ID
   ```

5. Capture outputs:
   ```bash
   npx cdk deploy --outputs-file outputs.json
   cat outputs.json
   ```
   Record the LoadBalancerDNS output - this is the gateway URL.

IMPORTANT: Deployment typically takes 5-10 minutes. The stack creates:
- VPC with subnets, NAT gateway, internet gateway
- ECS cluster
- ECR repository (implicit from fromAsset)
- Docker image build and push
- ALB with target group
- Fargate service and task definition
- IAM roles and security groups
- CloudWatch log group

If deployment fails, check:
- AWS credentials have sufficient permissions
- Region has capacity for requested resources
- Docker is running (needed for image build)
  </action>
  <verify>
`npx cdk deploy` completes with "Stack McpGatewayStack deployed successfully".
Stack outputs show LoadBalancerDNS value.
AWS Console shows ECS service with RUNNING task(s).
  </verify>
  <done>
CDK stack deployed to AWS. ECS service running with at least 1 healthy task. ALB DNS available for traffic routing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify production deployment</name>
  <files></files>
  <action>
Verify the deployed gateway is functioning correctly:

1. Get the ALB DNS from stack outputs:
   ```bash
   cd infra
   ALB_DNS=$(aws cloudformation describe-stacks \
     --stack-name McpGatewayStack \
     --query "Stacks[0].Outputs[?OutputKey=='LoadBalancerDNS'].OutputValue" \
     --output text)
   echo "Gateway URL: http://$ALB_DNS"
   ```

2. Test health endpoint:
   ```bash
   curl -v http://$ALB_DNS/health
   ```
   Should return `{"status":"ok","timestamp":"..."}` with 200 status.

3. Check ECS service status:
   ```bash
   aws ecs describe-services \
     --cluster McpGatewayCluster \
     --services McpGatewayService \
     --query "services[0].{status:status,running:runningCount,desired:desiredCount,health:healthCheckGracePeriodSeconds}"
   ```
   Should show status=ACTIVE, runningCount >= 1.

4. Check target group health:
   ```bash
   TG_ARN=$(aws elbv2 describe-target-groups \
     --names McpGateway-TG \
     --query "TargetGroups[0].TargetGroupArn" \
     --output text 2>/dev/null || echo "")

   if [ -n "$TG_ARN" ]; then
     aws elbv2 describe-target-health \
       --target-group-arn $TG_ARN \
       --query "TargetHealthDescriptions[*].{target:Target.Id,health:TargetHealth.State}"
   fi
   ```
   Targets should be "healthy".

5. Check CloudWatch logs for any errors:
   ```bash
   aws logs tail /ecs/mcp-gateway --since 10m
   ```
   Should show server startup logs without critical errors.

6. Test OAuth flow initiation (will redirect, just verify endpoint exists):
   ```bash
   curl -v -o /dev/null -w "%{http_code}" http://$ALB_DNS/oauth/login
   ```
   Should return 302 (redirect to Google OAuth).

7. Document the production URL:
   ```
   Production Gateway URL: http://<ALB_DNS>
   Update Cursor MCP configuration to use this URL.
   ```

NOTE: Full OAuth flow requires updating GOOGLE_REDIRECT_URI in Google Cloud Console to use the production ALB URL. This is a user action outside of CDK deployment.
  </action>
  <verify>
Health endpoint returns 200 with JSON response.
ECS service shows at least 1 running task.
Target group health checks pass.
CloudWatch logs show successful server startup.
OAuth login endpoint returns 302 redirect.
  </verify>
  <done>
Gateway deployed and verified on AWS. Health checks passing, service stable, logs accessible. INFRA-02 requirement complete.
  </done>
</task>

</tasks>

<verification>
1. CDK project in infra/ compiles and synthesizes CloudFormation
2. `cdk deploy` completes successfully
3. ECS service running with healthy task(s)
4. ALB health checks passing (HTTP 200 on /health)
5. CloudWatch logs show server startup
6. Production URL accessible from internet
7. Auto-scaling configured (1-3 tasks based on connections)
</verification>

<success_criteria>
- CDK infrastructure project exists and compiles
- Stack deployed to AWS with VPC, ECS, ALB
- Gateway running as Fargate task
- Health endpoint accessible via ALB DNS
- CloudWatch logs capturing application output
- Auto-scaling rules in place (even if not triggered yet)
- INFRA-02: Gateway deployed on AWS ECS/Fargate - COMPLETE
</success_criteria>

<output>
After completion, create `.planning/phases/06-aws-deployment/06-02-SUMMARY.md`
</output>
