---
phase: 06-aws-deployment
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - infra/bin/app.ts
  - infra/lib/fargate-stack.ts
  - infra/cdk.json
  - infra/package.json
  - infra/tsconfig.json
autonomous: true
user_setup:
  - service: aws
    why: "CDK deployment requires AssumeCorpAdmin role in Vim IT Corp account"
    account_id: "232282424912"
    account_name: "Vim IT Corp"
    role: "AssumeCorpAdmin"
    env_vars:
      - name: AWS_PROFILE
        source: "AWS SSO profile configured to assume AssumeCorpAdmin role"
      - name: AWS_REGION
        source: "Default region for deployment (e.g., us-east-1)"
    dashboard_config:
      - task: "Ensure AWS SSO login is active for AssumeCorpAdmin @ 232282424912"
        location: "Run: aws sso login --profile <your-sso-profile>"

must_haves:
  truths:
    - "Gateway runs as containerized service on ECS Fargate cluster"
    - "Application Load Balancer routes HTTP traffic to Fargate tasks on port 80"
    - "Gateway scales automatically from 1-3 tasks based on connection load (50/100 connection thresholds)"
    - "Health check endpoint enables automatic task restart on failures"
    - "Users connect to production ALB DNS URL without localhost or port configuration"
  artifacts:
    - path: "infra/bin/app.ts"
      provides: "CDK app entry point"
      contains: "new McpGatewayStack"
    - path: "infra/lib/fargate-stack.ts"
      provides: "ECS Fargate stack definition"
      contains: "ApplicationLoadBalancedFargateService"
    - path: "infra/cdk.json"
      provides: "CDK configuration"
      contains: "app"
    - path: "infra/package.json"
      provides: "CDK dependencies"
      contains: "aws-cdk-lib"
  key_links:
    - from: "infra/lib/fargate-stack.ts"
      to: "Dockerfile"
      via: "ContainerImage.fromAsset"
      pattern: "ContainerImage\\.fromAsset"
    - from: "infra/lib/fargate-stack.ts"
      to: "DynamoDB table"
      via: "Table.fromTableName + grantReadWriteData"
      pattern: "Table\\.fromTableName.*mcp-gateway-sessions.*grantReadWriteData"
    - from: "infra/lib/fargate-stack.ts"
      to: "KMS key"
      via: "Key.fromKeyArn + grantEncryptDecrypt"
      pattern: "Key\\.fromKeyArn.*grantEncryptDecrypt"
    - from: "infra/lib/fargate-stack.ts"
      to: "taskImageOptions.environment"
      via: "CDK context variables"
      pattern: "environment:.*GOOGLE_CLIENT_ID.*tryGetContext"
---

<objective>
Create AWS CDK infrastructure for deploying the MCP Gateway on ECS Fargate with Application Load Balancer, auto-scaling, and proper IAM permissions.

Purpose: The gateway needs production infrastructure that handles HTTP traffic (HTTPS with custom domain deferred for POC), scales based on connection load, integrates with existing DynamoDB/KMS resources, and restarts unhealthy tasks automatically.

Output: Complete CDK stack that can be deployed with `cdk deploy`, creating VPC, ECS cluster, Fargate service, ALB, and all supporting infrastructure.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-aws-deployment/06-RESEARCH.md
@.planning/phases/06-aws-deployment/06-01-SUMMARY.md

# Dockerfile from Plan 06-01
@Dockerfile

# Current environment configuration
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CDK infrastructure project with complete fargate-stack.ts</name>
  <files>infra/bin/app.ts, infra/lib/fargate-stack.ts, infra/cdk.json, infra/package.json, infra/tsconfig.json</files>
  <action>
Create the CDK infrastructure project in the `infra/` directory with the following files:

1. **infra/package.json**:
```json
{
  "name": "mcp-gateway-infra",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "build": "tsc",
    "cdk": "cdk",
    "synth": "cdk synth",
    "deploy": "cdk deploy",
    "destroy": "cdk destroy"
  },
  "devDependencies": {
    "@types/node": "^22.0.0",
    "aws-cdk": "^2.180.0",
    "typescript": "^5.9.0"
  },
  "dependencies": {
    "aws-cdk-lib": "^2.180.0",
    "constructs": "^10.4.0",
    "source-map-support": "^0.5.21"
  }
}
```

2. **infra/tsconfig.json**:
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "lib": ["ES2022"],
    "strict": true,
    "noEmitOnError": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "dist",
    "declaration": true
  },
  "include": ["bin/**/*", "lib/**/*"],
  "exclude": ["node_modules", "dist", "cdk.out"]
}
```

3. **infra/cdk.json**:
```json
{
  "app": "npx ts-node --esm bin/app.ts",
  "watch": {
    "include": ["**"],
    "exclude": ["node_modules", "cdk.out", "**/*.d.ts", "**/*.js"]
  },
  "context": {
    "@aws-cdk/aws-lambda:recognizeLayerVersion": true,
    "@aws-cdk/core:checkSecretUsage": true,
    "@aws-cdk/core:target-partitions": ["aws"]
  }
}
```

4. **infra/bin/app.ts** (CDK app entry point):
```typescript
#!/usr/bin/env node
import 'source-map-support/register.js';
import * as cdk from 'aws-cdk-lib';
import { McpGatewayStack } from '../lib/fargate-stack.js';

const app = new cdk.App();

// Deploy to Vim IT Corp account (232282424912) using AssumeCorpAdmin role
new McpGatewayStack(app, 'McpGatewayStack', {
  env: {
    account: '232282424912',  // Vim IT Corp
    region: process.env.CDK_DEFAULT_REGION || 'us-east-1',
  },
  description: 'MCP Gateway for Google Workspace - ECS Fargate deployment',
});
```

5. **infra/lib/fargate-stack.ts** (complete implementation):
```typescript
import * as cdk from 'aws-cdk-lib';
import * as ec2 from 'aws-cdk-lib/aws-ec2';
import * as ecs from 'aws-cdk-lib/aws-ecs';
import * as ecs_patterns from 'aws-cdk-lib/aws-ecs-patterns';
import * as logs from 'aws-cdk-lib/aws-logs';
import * as dynamodb from 'aws-cdk-lib/aws-dynamodb';
import * as kms from 'aws-cdk-lib/aws-kms';
import { Construct } from 'constructs';

export class McpGatewayStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Get configuration from CDK context (passed via --context or cdk.json)
    const googleClientId = this.node.tryGetContext('googleClientId') || process.env.GOOGLE_CLIENT_ID;
    const googleClientSecret = this.node.tryGetContext('googleClientSecret') || process.env.GOOGLE_CLIENT_SECRET;
    const googleRedirectUri = this.node.tryGetContext('googleRedirectUri') || process.env.GOOGLE_REDIRECT_URI;
    const allowedDomain = this.node.tryGetContext('allowedDomain') || process.env.ALLOWED_DOMAIN;
    const sessionSecret = this.node.tryGetContext('sessionSecret') || process.env.SESSION_SECRET;
    const kmsKeyArn = this.node.tryGetContext('kmsKeyArn') || process.env.KMS_KEY_ARN;
    const dynamoTableName = this.node.tryGetContext('dynamoTableName') || 'mcp-gateway-sessions';

    // VPC with 2 AZs and 1 NAT Gateway (cost optimization for 20 users)
    const vpc = new ec2.Vpc(this, 'McpGatewayVpc', {
      maxAzs: 2,
      natGateways: 1,
    });

    // ECS Cluster with Container Insights enabled
    const cluster = new ecs.Cluster(this, 'McpGatewayCluster', {
      vpc,
      containerInsights: true,
    });

    // Reference existing DynamoDB table (created in Phase 2)
    const sessionsTable = dynamodb.Table.fromTableName(
      this,
      'SessionsTable',
      dynamoTableName
    );

    // Reference existing KMS key (created in Phase 2)
    // KMS key ARN must be provided via context or environment
    const encryptionKey = kmsKeyArn
      ? kms.Key.fromKeyArn(this, 'EncryptionKey', kmsKeyArn)
      : undefined;

    // Fargate service with ALB (HTTP on port 80 for initial deployment)
    const fargateService = new ecs_patterns.ApplicationLoadBalancedFargateService(
      this,
      'McpGatewayService',
      {
        cluster,
        cpu: 512,  // 0.5 vCPU
        memoryLimitMiB: 1024,  // 1 GB (valid Fargate combination)
        desiredCount: 1,  // Start with 1 task, auto-scaling handles the rest
        platformVersion: ecs.FargatePlatformVersion.LATEST,

        taskImageOptions: {
          // Build Docker image from project root (where Dockerfile is)
          image: ecs.ContainerImage.fromAsset('../', {
            file: 'Dockerfile',
          }),
          containerPort: 3000,

          // Environment variables passed to container
          environment: {
            NODE_ENV: 'production',
            PORT: '3000',
            AWS_REGION: cdk.Stack.of(this).region,
            DYNAMODB_TABLE_NAME: dynamoTableName,
            // OAuth and sensitive config from CDK context
            GOOGLE_CLIENT_ID: googleClientId || '',
            GOOGLE_CLIENT_SECRET: googleClientSecret || '',
            GOOGLE_REDIRECT_URI: googleRedirectUri || '',
            ALLOWED_DOMAIN: allowedDomain || '',
            SESSION_SECRET: sessionSecret || '',
            KMS_KEY_ID: kmsKeyArn || '',
          },

          // CloudWatch logging with 7-day retention
          logDriver: ecs.LogDrivers.awsLogs({
            streamPrefix: 'mcp-gateway',
            logRetention: logs.RetentionDays.ONE_WEEK,
          }),
        },

        // HTTP listener on port 80 (HTTPS with custom domain deferred)
        publicLoadBalancer: true,
        listenerPort: 80,

        // Deployment configuration with circuit breaker
        circuitBreaker: { rollback: true },
        minHealthyPercent: 100,
        maxHealthyPercent: 200,

        // Health check grace period for container startup
        healthCheckGracePeriod: cdk.Duration.seconds(60),
      }
    );

    // Configure ALB target group health check
    fargateService.targetGroup.configureHealthCheck({
      path: '/health',
      interval: cdk.Duration.seconds(30),
      timeout: cdk.Duration.seconds(5),
      healthyThresholdCount: 2,
      unhealthyThresholdCount: 3,
      healthyHttpCodes: '200',
    });

    // Grant DynamoDB read/write access to task role
    sessionsTable.grantReadWriteData(fargateService.taskDefinition.taskRole);

    // Grant KMS encrypt/decrypt access to task role (if key provided)
    if (encryptionKey) {
      encryptionKey.grantEncryptDecrypt(fargateService.taskDefinition.taskRole);
    }

    // Auto-scaling based on connection count (1-3 tasks)
    const scaling = fargateService.service.autoScaleTaskCount({
      minCapacity: 1,
      maxCapacity: 3,
    });

    // Scale on active connection count
    // 0-50 connections: 1 task
    // 50-100 connections: 2 tasks
    // 100+ connections: 3 tasks
    scaling.scaleOnMetric('ConnectionScaling', {
      metric: fargateService.targetGroup.metricActiveConnectionCount({
        statistic: 'Average',
        period: cdk.Duration.minutes(1),
      }),
      scalingSteps: [
        { upper: 50, change: 0 },     // 0-50 connections: maintain current (1 task)
        { lower: 50, change: +1 },    // 50+ connections: add 1 task
        { lower: 100, change: +1 },   // 100+ connections: add another task
      ],
      adjustmentType: cdk.aws_applicationautoscaling.AdjustmentType.CHANGE_IN_CAPACITY,
    });

    // Stack outputs
    new cdk.CfnOutput(this, 'LoadBalancerDNS', {
      value: fargateService.loadBalancer.loadBalancerDnsName,
      description: 'ALB DNS name - use this as production URL',
      exportName: 'McpGatewayALBDNS',
    });

    new cdk.CfnOutput(this, 'ServiceArn', {
      value: fargateService.service.serviceArn,
      description: 'ECS service ARN',
      exportName: 'McpGatewayServiceArn',
    });

    new cdk.CfnOutput(this, 'ClusterName', {
      value: cluster.clusterName,
      description: 'ECS cluster name',
      exportName: 'McpGatewayClusterName',
    });
  }
}
```

IMPORTANT NOTES:
- Uses HTTP on port 80 (not HTTPS). HTTPS requires ACM certificate + custom domain, which can be added post-deployment following ROADMAP.md Phase 6 Notes.
- Environment variables are passed via CDK context or environment variables at deploy time. For production, consider migrating sensitive values to AWS Secrets Manager.
- DynamoDB table must exist with name "mcp-gateway-sessions" (created in Phase 2).
- KMS key ARN must be provided if encryption is enabled.
  </action>
  <verify>
Run from infra/ directory:
- `npm install` completes without errors
- `npm run build` compiles TypeScript without errors
- `npx cdk synth` generates CloudFormation template (may warn about missing AWS credentials or context values)
  </verify>
  <done>
CDK infrastructure project exists with valid TypeScript, compiles successfully, and synthesizes CloudFormation template. fargate-stack.ts includes complete implementation with DynamoDB/KMS grants, CDK context for environment variables, and HTTP on port 80.
  </done>
</task>

<task type="auto">
  <name>Task 2: Deploy CDK stack to AWS</name>
  <files></files>
  <action>
Deploy the CDK stack to AWS using the AssumeCorpAdmin role in the Vim IT Corp account (232282424912):

1. First, ensure you're authenticated with the correct role:
   ```bash
   # Verify you're using AssumeCorpAdmin @ 232282424912
   aws sts get-caller-identity
   ```
   Expected output should show:
   - Account: 232282424912
   - Arn: contains "AssumeCorpAdmin"

   If not authenticated, login via AWS SSO:
   ```bash
   aws sso login --profile <your-vim-corp-profile>
   export AWS_PROFILE=<your-vim-corp-profile>
   ```

2. Get the KMS key ARN (from Phase 2):
   ```bash
   # List KMS keys to find the mcp-gateway key
   aws kms list-aliases --query "Aliases[?contains(AliasName, 'mcp-gateway')]"
   ```

3. Bootstrap CDK (required once per account/region):
   ```bash
   cd infra
   npx cdk bootstrap
   ```
   This creates the CDKToolkit stack with S3 bucket for assets.

4. Synthesize and review the stack:
   ```bash
   npx cdk synth
   ```
   Review the generated CloudFormation in cdk.out/ to verify resources.

5. Deploy the stack with required context values:
   ```bash
   npx cdk deploy --require-approval never \
     --context googleClientId="$GOOGLE_CLIENT_ID" \
     --context googleClientSecret="$GOOGLE_CLIENT_SECRET" \
     --context googleRedirectUri="$GOOGLE_REDIRECT_URI" \
     --context allowedDomain="$ALLOWED_DOMAIN" \
     --context sessionSecret="$SESSION_SECRET" \
     --context kmsKeyArn="$KMS_KEY_ARN" \
     --context dynamoTableName="mcp-gateway-sessions"
   ```

   Alternatively, set environment variables before deploy:
   ```bash
   export GOOGLE_CLIENT_ID="your-client-id"
   export GOOGLE_CLIENT_SECRET="your-client-secret"
   # ... etc
   npx cdk deploy --require-approval never
   ```

6. Capture outputs:
   ```bash
   npx cdk deploy --outputs-file outputs.json
   cat outputs.json
   ```
   Record the LoadBalancerDNS output - this is the production gateway URL.

IMPORTANT: Deployment typically takes 5-10 minutes. The stack creates:
- VPC with subnets, NAT gateway, internet gateway
- ECS cluster with Container Insights
- ECR repository (implicit from fromAsset)
- Docker image build and push
- ALB with target group (HTTP on port 80)
- Fargate service and task definition
- IAM roles and security groups
- CloudWatch log group
- Auto-scaling rules (1-3 tasks based on connections)

If deployment fails, check:
- AWS credentials have sufficient permissions (ECS, ECR, VPC, IAM)
- Region has capacity for requested resources
- Docker is running (needed for image build)
- All required context values are provided
  </action>
  <verify>
`npx cdk deploy` completes with "Stack McpGatewayStack deployed successfully".
Stack outputs show LoadBalancerDNS value.
AWS Console shows ECS service with RUNNING task(s).
  </verify>
  <done>
CDK stack deployed to AWS. ECS service running with at least 1 healthy task. ALB DNS available for HTTP traffic routing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify production deployment</name>
  <files></files>
  <action>
Verify the deployed gateway is functioning correctly:

1. Get the ALB DNS from stack outputs:
   ```bash
   cd infra
   ALB_DNS=$(aws cloudformation describe-stacks \
     --stack-name McpGatewayStack \
     --query "Stacks[0].Outputs[?OutputKey=='LoadBalancerDNS'].OutputValue" \
     --output text)
   echo "Gateway URL: http://$ALB_DNS"
   ```

2. Test health endpoint:
   ```bash
   curl -v http://$ALB_DNS/health
   ```
   Should return `{"status":"ok","timestamp":"..."}` with 200 status.

3. Check ECS service status:
   ```bash
   CLUSTER_NAME=$(aws cloudformation describe-stacks \
     --stack-name McpGatewayStack \
     --query "Stacks[0].Outputs[?OutputKey=='ClusterName'].OutputValue" \
     --output text)

   aws ecs list-services --cluster $CLUSTER_NAME

   SERVICE_ARN=$(aws ecs list-services --cluster $CLUSTER_NAME --query "serviceArns[0]" --output text)

   aws ecs describe-services \
     --cluster $CLUSTER_NAME \
     --services $SERVICE_ARN \
     --query "services[0].{status:status,running:runningCount,desired:desiredCount}"
   ```
   Should show status=ACTIVE, runningCount >= 1.

4. Check target group health:
   ```bash
   # Find the target group
   TG_ARN=$(aws elbv2 describe-target-groups \
     --query "TargetGroups[?contains(TargetGroupName, 'McpGa')].TargetGroupArn" \
     --output text | head -1)

   if [ -n "$TG_ARN" ]; then
     aws elbv2 describe-target-health \
       --target-group-arn $TG_ARN \
       --query "TargetHealthDescriptions[*].{target:Target.Id,health:TargetHealth.State}"
   fi
   ```
   Targets should be "healthy".

5. Check CloudWatch logs for any errors:
   ```bash
   aws logs tail /ecs/mcp-gateway --since 10m 2>/dev/null || \
   aws logs tail /aws/ecs/mcp-gateway --since 10m
   ```
   Should show server startup logs without critical errors.

6. Test OAuth flow initiation (will redirect, just verify endpoint exists):
   ```bash
   curl -v -o /dev/null -w "%{http_code}" "http://$ALB_DNS/oauth/login"
   ```
   Should return 302 (redirect to Google OAuth).

7. Document the production URL:
   ```
   Production Gateway URL: http://<ALB_DNS>

   IMPORTANT: Before using OAuth flow:
   1. Update GOOGLE_REDIRECT_URI in Google Cloud Console to: http://<ALB_DNS>/oauth/callback
   2. Re-deploy with updated googleRedirectUri context value
   ```

NOTE: Full OAuth flow requires updating GOOGLE_REDIRECT_URI in Google Cloud Console to use the production ALB URL. This is a user action outside of CDK deployment.
  </action>
  <verify>
Health endpoint returns 200 with JSON response.
ECS service shows at least 1 running task.
Target group health checks pass.
CloudWatch logs show successful server startup.
OAuth login endpoint returns 302 redirect.
  </verify>
  <done>
Gateway deployed and verified on AWS. Health checks passing, service stable, logs accessible. Users can connect to production ALB DNS URL. INFRA-02 requirement complete.
  </done>
</task>

</tasks>

<verification>
1. CDK project in infra/ compiles and synthesizes CloudFormation
2. `cdk deploy` completes successfully
3. ECS service running with healthy task(s)
4. ALB health checks passing (HTTP 200 on /health)
5. CloudWatch logs show server startup
6. Production ALB DNS URL accessible from internet (HTTP)
7. Auto-scaling configured (1-3 tasks based on 50/100 connection thresholds)
8. DynamoDB table access granted to task role
9. KMS key access granted to task role (if ARN provided)
</verification>

<success_criteria>
- CDK infrastructure project exists and compiles
- Stack deployed to AWS with VPC, ECS, ALB
- Gateway running as Fargate task
- Health endpoint accessible via ALB DNS (HTTP on port 80)
- CloudWatch logs capturing application output
- Auto-scaling rules in place (1-3 tasks, 50/100 connection thresholds)
- DynamoDB and KMS IAM permissions configured
- INFRA-02: Gateway deployed on AWS ECS/Fargate - COMPLETE
</success_criteria>

<output>
After completion, create `.planning/phases/06-aws-deployment/06-02-SUMMARY.md`
</output>
