---
phase: 03-gmail-integration
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - src/gmail/handlers.ts
  - src/mcp/handlers.ts
autonomous: false

must_haves:
  truths:
    - "User can search Gmail messages by query via MCP tool"
    - "User can list messages from inbox/labels via MCP tool"
    - "User can read full email content and metadata via MCP tool"
    - "Pagination supported for search and list operations"
    - "Token expiration returns clear re-authentication message"
  artifacts:
    - path: "src/gmail/handlers.ts"
      provides: "Gmail MCP tool implementations"
      exports: ["registerGmailHandlers"]
      min_lines: 150
    - path: "src/mcp/handlers.ts"
      provides: "MCP handler registration including Gmail"
      contains: "registerGmailHandlers"
  key_links:
    - from: "src/gmail/handlers.ts"
      to: "src/gmail/client.ts"
      via: "createGmailClient import"
      pattern: "createGmailClient"
    - from: "src/gmail/handlers.ts"
      to: "src/gmail/parsers.ts"
      via: "parseMessageSummary, parseFullMessage imports"
      pattern: "parseMessageSummary|parseFullMessage"
    - from: "src/mcp/handlers.ts"
      to: "src/gmail/handlers.ts"
      via: "registerGmailHandlers import and call"
      pattern: "registerGmailHandlers"
---

<objective>
Implement Gmail MCP tools (search, list, get) and register them with the MCP server.

Purpose: Enable Cursor users to search, list, and read Gmail messages through natural language queries via MCP tools.

Output: Three working Gmail tools (gmail_search, gmail_list, gmail_get) with pagination support, proper error handling, and user verification.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-gmail-integration/03-RESEARCH.md
@.planning/phases/03-gmail-integration/03-02-SUMMARY.md

# Relevant source files
@src/mcp/handlers.ts
@src/gmail/client.ts
@src/gmail/parsers.ts
@src/gmail/types.ts
@src/auth/middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Gmail MCP Tools</name>
  <files>src/gmail/handlers.ts, src/mcp/handlers.ts</files>
  <action>
Create `src/gmail/handlers.ts` with three MCP tool implementations:

```typescript
/**
 * Gmail MCP tool handlers
 * Implements gmail_search, gmail_list, gmail_get tools
 */
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { UserContext } from '../auth/middleware.js';
import { createGmailClient } from './client.js';
import { parseMessageSummary, parseFullMessage } from './parsers.js';
import type { GmailSearchResult, GmailGetResult } from './types.js';

/**
 * Extract user context from MCP extra parameter
 */
function getUserContext(extra: any): UserContext | null {
  return (extra?.transport as any)?.userContext as UserContext | null;
}

/**
 * Handle Gmail API errors and return appropriate MCP response
 */
function handleGmailError(error: any): { content: Array<{ type: 'text'; text: string }>; isError: true } {
  const code = error.code || error.response?.status || 500;
  const message = error.message || 'Unknown Gmail API error';

  // Token expiration - direct user to re-authenticate
  if (code === 401) {
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          error: 'token_expired',
          code: 401,
          message: 'Access token expired. Please re-authenticate at /auth/login'
        }, null, 2)
      }],
      isError: true
    };
  }

  // Insufficient permissions - need to re-authenticate with Gmail scope
  if (code === 403 && message.includes('insufficient')) {
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          error: 'insufficient_scope',
          code: 403,
          message: 'Gmail access not authorized. Please re-authenticate at /auth/login to grant Gmail permissions.'
        }, null, 2)
      }],
      isError: true
    };
  }

  // Rate limit - suggest retry
  if (code === 429 || (code === 403 && message.includes('rate'))) {
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          error: 'rate_limited',
          code: code,
          message: 'Gmail API rate limit exceeded. Please wait a moment and try again.'
        }, null, 2)
      }],
      isError: true
    };
  }

  // Generic error
  return {
    content: [{
      type: 'text',
      text: JSON.stringify({
        error: 'gmail_api_error',
        code: code,
        message: message
      }, null, 2)
    }],
    isError: true
  };
}

/**
 * Register Gmail tools with MCP server
 */
export function registerGmailHandlers(server: McpServer): void {
  // gmail_search - Search messages by query
  server.registerTool('gmail_search', {
    description: 'Search Gmail messages using Gmail search syntax (e.g., "from:user@example.com", "subject:meeting", "is:unread")',
    inputSchema: {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'Gmail search query (supports Gmail search operators)'
        },
        maxResults: {
          type: 'number',
          description: 'Maximum number of results (1-50, default 10)',
          default: 10
        },
        pageToken: {
          type: 'string',
          description: 'Pagination token from previous search result'
        }
      },
      required: ['query']
    }
  }, async (args, extra) => {
    const userContext = getUserContext(extra);
    if (!userContext) {
      return {
        content: [{ type: 'text', text: 'Error: No user context. Please authenticate.' }],
        isError: true
      };
    }

    try {
      const gmail = createGmailClient(userContext);
      const maxResults = Math.min(Math.max(args.maxResults || 10, 1), 50);

      // Search for message IDs
      const listResponse = await gmail.users.messages.list({
        userId: 'me',
        q: args.query as string,
        maxResults,
        pageToken: args.pageToken as string | undefined
      });

      const messageIds = listResponse.data.messages || [];

      // Fetch metadata for each message (batch with format=metadata for efficiency)
      const messages = await Promise.all(
        messageIds.map(async (msg) => {
          const detail = await gmail.users.messages.get({
            userId: 'me',
            id: msg.id!,
            format: 'metadata',
            metadataHeaders: ['From', 'To', 'Subject', 'Date']
          });
          return parseMessageSummary(detail.data);
        })
      );

      const result: GmailSearchResult = {
        messages,
        nextPageToken: listResponse.data.nextPageToken || null,
        resultSizeEstimate: listResponse.data.resultSizeEstimate || 0
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(result, null, 2)
        }]
      };
    } catch (error) {
      return handleGmailError(error);
    }
  });

  // gmail_list - List messages from inbox or specific label
  server.registerTool('gmail_list', {
    description: 'List Gmail messages from inbox or specific labels',
    inputSchema: {
      type: 'object',
      properties: {
        labelIds: {
          type: 'array',
          items: { type: 'string' },
          description: 'Label IDs to filter by (e.g., ["INBOX"], ["UNREAD"], ["STARRED"]). Default is INBOX.',
          default: ['INBOX']
        },
        maxResults: {
          type: 'number',
          description: 'Maximum number of results (1-50, default 10)',
          default: 10
        },
        pageToken: {
          type: 'string',
          description: 'Pagination token from previous list result'
        }
      },
      required: []
    }
  }, async (args, extra) => {
    const userContext = getUserContext(extra);
    if (!userContext) {
      return {
        content: [{ type: 'text', text: 'Error: No user context. Please authenticate.' }],
        isError: true
      };
    }

    try {
      const gmail = createGmailClient(userContext);
      const maxResults = Math.min(Math.max(args.maxResults || 10, 1), 50);
      const labelIds = (args.labelIds as string[] | undefined) || ['INBOX'];

      // List message IDs by label
      const listResponse = await gmail.users.messages.list({
        userId: 'me',
        labelIds,
        maxResults,
        pageToken: args.pageToken as string | undefined
      });

      const messageIds = listResponse.data.messages || [];

      // Fetch metadata for each message
      const messages = await Promise.all(
        messageIds.map(async (msg) => {
          const detail = await gmail.users.messages.get({
            userId: 'me',
            id: msg.id!,
            format: 'metadata',
            metadataHeaders: ['From', 'To', 'Subject', 'Date']
          });
          return parseMessageSummary(detail.data);
        })
      );

      const result: GmailSearchResult = {
        messages,
        nextPageToken: listResponse.data.nextPageToken || null,
        resultSizeEstimate: listResponse.data.resultSizeEstimate || 0
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(result, null, 2)
        }]
      };
    } catch (error) {
      return handleGmailError(error);
    }
  });

  // gmail_get - Get full message content by ID
  server.registerTool('gmail_get', {
    description: 'Get full email content including body and attachment metadata by message ID',
    inputSchema: {
      type: 'object',
      properties: {
        messageId: {
          type: 'string',
          description: 'Gmail message ID (from search or list results)'
        }
      },
      required: ['messageId']
    }
  }, async (args, extra) => {
    const userContext = getUserContext(extra);
    if (!userContext) {
      return {
        content: [{ type: 'text', text: 'Error: No user context. Please authenticate.' }],
        isError: true
      };
    }

    try {
      const gmail = createGmailClient(userContext);

      // Get full message with body
      const response = await gmail.users.messages.get({
        userId: 'me',
        id: args.messageId as string,
        format: 'full'
      });

      const message = parseFullMessage(response.data);

      const result: GmailGetResult = { message };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(result, null, 2)
        }]
      };
    } catch (error) {
      return handleGmailError(error);
    }
  });

  console.log('[MCP] Gmail handlers registered: gmail_search, gmail_list, gmail_get');
}
```

Then update `src/mcp/handlers.ts` to register Gmail handlers:

1. Add import at top:
   ```typescript
   import { registerGmailHandlers } from '../gmail/handlers.js';
   ```

2. Add call in registerMcpHandlers() function (at the end, before the console.log):
   ```typescript
   // Register Gmail tools
   registerGmailHandlers(server);
   ```

3. Update the final console.log to include Gmail tools:
   ```typescript
   console.log('[MCP] Handlers registered: whoami, test_auth, gmail_search, gmail_list, gmail_get');
   ```

**Important patterns from RESEARCH.md:**
- Create gmail client per tool invocation (not shared)
- Use format=metadata for list/search (faster than full)
- Use format=full only for gmail_get (includes body)
- Handle 401 (token expired) with re-auth message
- Handle 403 (insufficient scope) with re-auth message
- Handle 429 (rate limit) with retry suggestion
- Limit maxResults to 50 (Gmail API limit)
- Return nextPageToken for pagination
  </action>
  <verify>
1. `ls src/gmail/handlers.ts` confirms file exists
2. `grep "gmail_search" src/gmail/handlers.ts` shows tool registration
3. `grep "gmail_list" src/gmail/handlers.ts` shows tool registration
4. `grep "gmail_get" src/gmail/handlers.ts` shows tool registration
5. `grep "registerGmailHandlers" src/mcp/handlers.ts` shows import and call
6. `npm run build` compiles without TypeScript errors
7. `npm run dev` starts server without errors
  </verify>
  <done>
src/gmail/handlers.ts implements gmail_search, gmail_list, gmail_get MCP tools. src/mcp/handlers.ts updated to register Gmail handlers. All three tools have pagination support and proper error handling for token expiration and rate limits.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: End-to-End Gmail Verification</name>
  <what-built>
Complete Gmail integration with three MCP tools:
- gmail_search: Search messages by query
- gmail_list: List messages from inbox/labels
- gmail_get: Read full message content

All tools use user's OAuth access token with gmail.readonly scope.
  </what-built>
  <how-to-verify>
**Pre-requisite:** You will need to re-authenticate to get the new Gmail scope.

1. **Start the server:**
   ```bash
   npm run dev
   ```

2. **Re-authenticate to get Gmail scope:**
   - Open browser to http://localhost:3000/auth/login
   - Complete Google OAuth flow
   - You should see a consent screen asking for Gmail read access (new scope)
   - After approval, you should be redirected back with success

3. **Test gmail_list (list inbox messages):**
   Using curl or MCP client, call the gmail_list tool with no parameters to list inbox.

   Expected result: JSON with messages array containing recent inbox emails (id, subject, from, etc.)

4. **Test gmail_search:**
   Call gmail_search with a query like `{"query": "is:unread"}` or a subject you know exists.

   Expected result: JSON with messages matching the query

5. **Test gmail_get:**
   Using a message ID from the list/search results, call gmail_get with `{"messageId": "..."}`.

   Expected result: JSON with full message including textBody or htmlBody content

6. **Verify pagination:**
   If you have more than 10 messages, the list/search result should include `nextPageToken`.

7. **Verify error handling (optional):**
   - If you test with an old session (before re-auth), should get "insufficient_scope" error
   - Server logs should show Gmail API calls

**What to check:**
- [ ] Re-authentication prompts for Gmail scope
- [ ] gmail_list returns inbox messages
- [ ] gmail_search finds messages matching query
- [ ] gmail_get returns full message with body content
- [ ] Results include proper fields (subject, from, date, etc.)
- [ ] Server logs show "[MCP] Gmail handlers registered"
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues encountered</resume-signal>
</task>

</tasks>

<verification>
Phase 3 requirements verification:

1. **GMAIL-01: User can search Gmail messages by query**
   - gmail_search tool with query parameter
   - Supports Gmail search operators (from:, subject:, is:unread, etc.)
   - Returns message summaries with pagination

2. **GMAIL-02: User can list messages from inbox/labels**
   - gmail_list tool with labelIds parameter
   - Supports multiple labels (INBOX, UNREAD, STARRED, etc.)
   - Returns message summaries with pagination

3. **GMAIL-03: User can read full email content and metadata**
   - gmail_get tool with messageId parameter
   - Returns full message with textBody, htmlBody, attachments metadata
   - Handles complex MIME structures via gmail-api-parse-message

4. **Token expiration handling:**
   - 401 errors return clear "re-authenticate at /auth/login" message
   - 403 insufficient scope errors direct to re-authentication
   - Rate limit errors suggest retry
</verification>

<success_criteria>
- gmail_search, gmail_list, gmail_get MCP tools registered and working
- User can search Gmail with natural language query and receive results
- User can list messages from specific inbox or label with pagination
- User can retrieve full email content including sender, subject, body, and metadata
- Token expiration returns actionable re-authentication message
- Human verification confirms end-to-end flow works
</success_criteria>

<output>
After completion, create `.planning/phases/03-gmail-integration/03-03-SUMMARY.md`
</output>
